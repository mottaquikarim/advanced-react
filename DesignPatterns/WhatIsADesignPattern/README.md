# What is a Design Pattern?

Design patterns are general, reusable bits of code that solve common issues in software design. They are meant to solve a *type* of problem, a problem that is more code design oriented vs concrete problem oriented.

## Example

For instance, suppose we wanted to define a **USCitizen** object in javascript. How could we define a **socialSecurityNumber** property of our object such that it is random and *also* private (in that this property is only accessible by the methods of **USCitizen** and not accessible in any other way?)

One option would be to do something as follows:

```js
const USCitizen = () => {
	// assume this is generated by some other function somewhere
	const socialSecurityNumber = 'XXX-XX-XXXX'; 
	return {
		vote() {
			return VotingServiceAPI
				.voteFor("someCandidate", socialSecurityNumber);
		}
	}
}

const john = USCitizen();
john.vote()
	.then(_ => console.log('Vote recorded successfully'))

// should this be possible...?
john.socialSecurityNumber; 
```

Ok, so what's happening here? We create a variable, **socialSecurityNumber** that lives *within* the scope of our **USCItizen** function. Notice however that nowhere is it *returned* outside of that function. This is significant because it implies that while the methods *inside* **USCItizen** will correctly be able to access that variable, nothing outside the scope can.

In the context of this example (a supposed online voting app), ensuring that the **socialSecurityNumber** variable is private is important - the **vote()** function seems to use that as a way to verify identity of a voter. As such, we don't want anyone to accidentally or nefariously **vote()** multiple times by resetting the social security number property over and over again! 

Thankfully, with the approach we took above, this cannot be possible since **socialSecurityNumber** is inaccessible outside of the **USCitizen** function.

#### But Where's the Pattern?

The **pattern** part of our above example comes when we ask ourselves: 

> What problem are we actually solving here?

In actuality, with our technique above, we are **not** solving the problem of obscuring a social security number from mutation outside of the function definition. That is too specific.

What we **are** solving is a more general problem: how do we **protect** *private* variables - values that should only be managed by the object definition / requirements - from outside mutation / access, either mistakenly or benignly? 

Our technique of writing a function that sets up values within a private scope - and returns *only* the properties and functions that should be / are allowed to be "publicly" accessible is an example of a tried and true javascript **design pattern**: the **Factory pattern**.

## Factory Design Pattern, Generalized

Let's take a look at what the above example could look like generalized. The idea here is to demonstrate that this pattern can be used anytime we would like to define an object to represent something while also maintaining a set of private properties that only the **object** can manage.

```js

const ObjectName = (arg1, arg2, ..., argN) => {
	const _privateArg1 = 0;
	const objectToExport = {};
	objectToExport.publicArg1 = arg1;
	objectToExport.publicArg2 = arg2;
	...
	objectToExport.publicArgN = argN;
	objectToExport.somePublicMethod = () => {
		// do something with privateArgs + publicArgs
		return _privateArg1 + objectToExport.publicArg1
	}
	
	return objectToExport;
}

// we can create objects by invoking the ObjectName function
const o = ObjectName(1,2,...,N)
const p = ObjectName(3,4,...,M)

o.publicArg1; // 1
p.publicArg2; // 4
o._privateArg; // does not exist!
p.somePublicMethod(); // privateArg1 + publicArg1 => 0 + 3 = 3

```

## Final thoughts

The factory pattern is very useful because it allows us to work with private variables - a feature that is built into other languages but unfortunately not javascript (yet). 

The main upsides to using this pattern are:

* Ability to define **truly** private variables in javascript 
* Ability to create objects without that pesky **new** keyword

The main downsides to using this pattern are:

* We are recreating an object on every function invocation - this isn't a *major* big deal but it is definitely not memory efficient (vs using the Object.prototype approach)


## Another Example

Suppose we wanted to have one handy function for updating the **innerText** of a DOM element. Believe it or not, this isn't super easy mainly because Firefox does not support the **Element.innerText** method, instead in Firefox it is necessary to leverage the **Element.textContent** method (specific to only Firefox). Now, if we only had one or two elements we wanted to update the texts of, this would be a no brainer. Just write some conditional statements and based on results, call one of the two methods as appropriate.

But suppose we are working in an application that needs to update text across a large codebase, and often. How can we come up with a solution that offloads the logic into one place that can be called over and over again, easily?

For starters, we can consider the following:

```js
const updateText = (el, text) => {
	if (el.innerText) { el.innerText = text; }
	else if (el.textContent) { el.textContent = text; }
	else { console.log('innerText and textContent are not defined');
}
```

Now, everywhere in the codebase we want to update text, instead of typing out the conditionals listed above, we can simply:

```js

updateText(document.body, 'Hello, Wrold!')
```

A great upside to this technique is that the logic needed to decide which method to go with is written in **ONE** place within **ONE** function. This means that when, ostensibly, browser support becomes more aligned it will be sufficient for us to simply make whatever updates necessary in that one function and have the change propagate throughout the codebase (whereever **updateText** is called).

Now, if you can imagine - this **pattern** can be applied to any type of situation where we may have to call one of several methods due to constrains (such a browser constraints, but can also be stuff like API calls or even just simple logic blocks that are often reused).

We call this pattern the **Facade Pattern**, since we are essentially erecting a common interface - the *facade* - that determines *how* to retrieve the information we request or perform the action we require.

As a side note, there is a library that you may have heard of that leverages this pattern *extensively* - it is called **jQuery**.
